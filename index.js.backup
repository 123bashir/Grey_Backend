import 'dotenv/config';
import express from 'express';
import cors from 'cors';
import bodyParser from 'body-parser';
import mysql from 'mysql2';
import { uploadToCloudinary, uploadMultipleToCloudinary } from './cloudinary.js';

const app = express();
const PORT = process.env.PORT || 8080;

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Database Connection Pool
const db = mysql.createPool({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASS || '',
    database: process.env.DB_NAME || 'greyinsaat_db',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
}).promise(); // Use promise-based API

// Test DB Connection
db.getConnection()
    .then(connection => {
        console.log('âœ… Connected to MySQL Database');
        connection.release();
    })
    .catch(err => {
        console.error('âŒ Database connection failed:', err.message);
    });

// ============================================
// AUTHENTICATION MIDDLEWARE
// ============================================
const authenticateUser = async (req, res, next) => {
    const authHeader = req.headers.authorization;

    if (!authHeader) {
        return res.status(401).json({ success: false, message: 'No authorization token provided' });
    }

    // Simple token validation (in production, use JWT)
    const token = authHeader.replace('Bearer ', '');

    try {
        // Extract user ID from token (simplified - use JWT in production)
        const userId = parseInt(token.split('-')[1]);

        const [users] = await db.execute('SELECT id, name, email, role FROM staff WHERE id = ? AND is_active = TRUE', [userId]);

        if (users.length === 0) {
            return res.status(401).json({ success: false, message: 'Invalid token' });
        }

        req.user = users[0];
        next();
    } catch (error) {
        return res.status(401).json({ success: false, message: 'Invalid token format' });
    }
};

// Role-based authorization
const requireRole = (...roles) => {
    return (req, res, next) => {
        if (!req.user || !roles.includes(req.user.role)) {
            return res.status(403).json({ success: false, message: 'Insufficient permissions' });
        }
        next();
    };
};

// ============================================
// AUTH ROUTES
// ============================================

// Login
app.post('/api/auth/login', async (req, res) => {
    const { email, password } = req.body;

    if (!email || !password) {
        return res.status(400).json({ success: false, message: 'Email and password are required' });
    }

    try {
        const [users] = await db.execute(
            'SELECT * FROM staff WHERE email = ? AND is_active = TRUE',
            [email]
        );

        if (users.length === 0) {
            return res.status(401).json({ success: false, message: 'Invalid email or password' });
        }

        const user = users[0];

        // Check password (use bcrypt in production)
        if (user.password !== password) {
            return res.status(401).json({ success: false, message: 'Invalid email or password' });
        }

        // Update last login
        await db.execute('UPDATE staff SET last_login = NOW() WHERE id = ?', [user.id]);

        // Generate token (use JWT in production)
        const token = `token-${user.id}-${Date.now()}`;

        res.json({
            success: true,
            message: 'Login successful',
            user: {
                id: user.id,
                email: user.email,
                name: user.name,
                role: user.role,
                avatar_url: user.avatar_url,
                department: user.department,
                position: user.position,
                token
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({ success: false, message: 'Internal server error' });
    }
});

const {
    name, type, status, client, description, location, address,
    start_date, end_date, total_budget, spent_budget, completion_percentage,
    project_manager, team_members, images, milestones
} = req.body;

// Validation
if (!name || !type || !client || !location || !start_date || !end_date || !total_budget || !project_manager) {
    return res.status(400).json({
        success: false,
        message: 'Missing required fields'
    });
}

const query = `
            INSERT INTO projects (
                name, type, status, client, description, location, address,
                start_date, end_date, total_budget, spent_budget, completion_percentage,
                project_manager, team_members, images, milestones, created_by
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;

const milestonesJson = milestones ? JSON.stringify(milestones) : null;
const imagesJson = images ? JSON.stringify(images) : null;

// Helper to format date for MySQL
const formatDateForMySQL = (isoDate) => {
    if (!isoDate) return null;
    return new Date(isoDate).toISOString().slice(0, 19).replace('T', ' ');
};

const formattedStartDate = formatDateForMySQL(start_date);
const formattedEndDate = formatDateForMySQL(end_date);

const [result] = await db.execute(query, [
    name, type, status || 'Planning', client, description, location, address,
    formattedStartDate, formattedEndDate, total_budget, spent_budget || 0, completion_percentage || 0,
    project_manager, team_members, imagesJson, milestonesJson, req.user.id
]);

res.status(201).json({
    success: true,
    message: 'Project created successfully',
    projectId: result.insertId
});
    } catch (error) {
    console.error('Create project error:', error);
    res.status(500).json({ success: false, message: 'Failed to create project' });
}
});

// Update project
app.put('/api/projects/:id', authenticateUser, async (req, res) => {
    try {
        const {
            name, type, status, client, description, location, address,
            start_date, end_date, total_budget, spent_budget, completion_percentage,
            project_manager, team_members, images, milestones
        } = req.body;

        // Helper to format date for MySQL
        const formatDateForMySQL = (isoDate) => {
            if (!isoDate) return null;
            return new Date(isoDate).toISOString().slice(0, 19).replace('T', ' ');
        };

        const formattedStartDate = formatDateForMySQL(start_date);
        const formattedEndDate = formatDateForMySQL(end_date);

        const query = `
            UPDATE projects SET
                name = ?, type = ?, status = ?, client = ?, description = ?,
                location = ?, address = ?, start_date = ?, end_date = ?,
                total_budget = ?, spent_budget = ?, completion_percentage = ?,
                project_manager = ?, team_members = ?, images = ?, milestones = ?
            WHERE id = ?
        `;

        const milestonesJson = milestones ? JSON.stringify(milestones) : null;
        const imagesJson = images ? JSON.stringify(images) : null;

        const [result] = await db.execute(query, [
            name, type, status, client, description, location, address,
            formattedStartDate, formattedEndDate, total_budget, spent_budget, completion_percentage,
            project_manager, team_members, imagesJson, milestonesJson, req.params.id
        ]);

        if (result.affectedRows === 0) {
            return res.status(404).json({ success: false, message: 'Project not found' });
        }

        res.json({
            success: true,
            message: 'Project updated successfully'
        });
    } catch (error) {
        console.error('Update project error:', error);
        res.status(500).json({ success: false, message: 'Failed to update project' });
    }
});

// Delete project
app.delete('/api/projects/:id', authenticateUser, async (req, res) => {
    try {
        const [result] = await db.execute('DELETE FROM projects WHERE id = ?', [req.params.id]);

        if (result.affectedRows === 0) {
            return res.status(404).json({ success: false, message: 'Project not found' });
        }

        res.json({
            success: true,
            message: 'Project deleted successfully'
        });
    } catch (error) {
        console.error('Delete project error:', error);
        res.status(500).json({ success: false, message: 'Failed to delete project' });
    }
});

// ============================================
// DASHBOARD ROUTES
// ============================================

// Get dashboard statistics
app.get('/api/dashboard/stats', authenticateUser, async (req, res) => {
    try {
        // Get project statistics
        const [projectStats] = await db.execute(`
            SELECT
                COUNT(*) as total_projects,
                SUM(CASE WHEN status = 'In Progress' THEN 1 ELSE 0 END) as active_projects,
                SUM(CASE WHEN status = 'Completed' THEN 1 ELSE 0 END) as completed_projects,
                SUM(CASE WHEN status = 'Planning' THEN 1 ELSE 0 END) as planning_projects,
                SUM(total_budget) as total_budget,
                SUM(spent_budget) as total_spent,
                AVG(completion_percentage) as avg_completion
            FROM projects
        `);

        // Get staff count
        const [staffStats] = await db.execute('SELECT COUNT(*) as total_staff FROM staff WHERE is_active = TRUE');

        // Get projects by type
        const [projectsByType] = await db.execute(`
            SELECT type, COUNT(*) as count
            FROM projects
            GROUP BY type
        `);

        // Get projects by status
        const [projectsByStatus] = await db.execute(`
            SELECT status, COUNT(*) as count
            FROM projects
            GROUP BY status
        `);

        // Get recent projects
        const [recentProjects] = await db.execute(`
            SELECT id, name, type, status, start_date, completion_percentage
            FROM projects
            ORDER BY created_at DESC
            LIMIT 5
        `);

        res.json({
            success: true,
            stats: {
                ...projectStats[0],
                total_staff: staffStats[0].total_staff,
                projects_by_type: projectsByType,
                projects_by_status: projectsByStatus,
                recent_projects: recentProjects
            }
        });
    } catch (error) {
        console.error('Dashboard stats error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch dashboard statistics' });
    }
});

// ============================================
// STAFF ROUTES (Super-Admin Only)
// ============================================

// Get all staff
app.get('/api/staff', authenticateUser, requireRole('super-admin'), async (req, res) => {
    try {
        const [staff] = await db.execute(`
            SELECT id, name, email, role, phone, department, position, avatar_url, is_active, last_login, created_at
            FROM staff
            ORDER BY created_at DESC
        `);

        res.json({
            success: true,
            count: staff.length,
            staff
        });
    } catch (error) {
        console.error('Get staff error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch staff' });
    }
});

// Get single staff member
app.get('/api/staff/:id', authenticateUser, async (req, res) => {
    try {
        const [staff] = await db.execute(`
            SELECT id, name, email, role, phone, department, position, avatar_url, is_active, last_login
            FROM staff
            WHERE id = ?
        `, [req.params.id]);

        if (staff.length === 0) {
            return res.status(404).json({ success: false, message: 'Staff member not found' });
        }

        res.json({
            success: true,
            staff: staff[0]
        });
    } catch (error) {
        console.error('Get staff member error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch staff member' });
    }
});

// Create new staff member (super-admin only)
app.post('/api/staff', authenticateUser, requireRole('super-admin'), async (req, res) => {
    try {
        const { name, email, password, role, phone, department, position, avatar_url } = req.body;

        if (!name || !email || !password) {
            return res.status(400).json({ success: false, message: 'Name, email, and password are required' });
        }

        const query = `
            INSERT INTO staff (name, email, password, role, phone, department, position, avatar_url, created_by)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;

        const [result] = await db.execute(query, [
            name, email, password, role || 'viewer', phone, department, position, avatar_url, req.user.id
        ]);

        res.status(201).json({
            success: true,
            message: 'Staff member created successfully',
            staffId: result.insertId
        });
    } catch (error) {
        if (error.code === 'ER_DUP_ENTRY') {
            return res.status(400).json({ success: false, message: 'Email already exists' });
        }
        console.error('Create staff error:', error);
        res.status(500).json({ success: false, message: 'Failed to create staff member' });
    }
});

// Update staff member
app.put('/api/staff/:id', authenticateUser, async (req, res) => {
    try {
        const { name, email, role, phone, department, position, avatar_url, is_active, password } = req.body;

        // Only super-admin can change roles or active status
        if ((role !== undefined || is_active !== undefined) && req.user.role !== 'super-admin') {
            return res.status(403).json({ success: false, message: 'Only super-admin can change role or status' });
        }

        // Build dynamic query based on provided fields
        const updates = [];
        const params = [];

        if (name !== undefined) {
            updates.push('name = ?');
            params.push(name);
        }
        if (email !== undefined) {
            updates.push('email = ?');
            params.push(email);
        }
        if (phone !== undefined) {
            updates.push('phone = ?');
            params.push(phone);
        }
        if (department !== undefined) {
            updates.push('department = ?');
            params.push(department);
        }
        if (position !== undefined) {
            updates.push('position = ?');
            params.push(position);
        }
        if (avatar_url !== undefined) {
            updates.push('avatar_url = ?');
            params.push(avatar_url);
        }

        // Super-admin only fields
        if (req.user.role === 'super-admin') {
            if (role !== undefined) {
                updates.push('role = ?');
                params.push(role);
            }
            if (is_active !== undefined) {
                updates.push('is_active = ?');
                params.push(is_active);
            }
        }

        if (password !== undefined) {
            updates.push('password = ?');
            params.push(password);
        }

        if (updates.length === 0) {
            return res.status(400).json({ success: false, message: 'No fields to update' });
        }

        const query = `UPDATE staff SET ${updates.join(', ')} WHERE id = ?`;
        params.push(req.params.id);

        const [result] = await db.execute(query, params);

        if (result.affectedRows === 0) {
            return res.status(404).json({ success: false, message: 'Staff member not found' });
        }

        res.json({
            success: true,
            message: 'Staff member updated successfully'
        });
    } catch (error) {
        console.error('Update staff error:', error);
        res.status(500).json({ success: false, message: 'Failed to update staff member' });
    }
});

// Delete staff member (super-admin only)
app.delete('/api/staff/:id', authenticateUser, requireRole('super-admin'), async (req, res) => {
    try {
        // Prevent deleting yourself
        if (parseInt(req.params.id) === req.user.id) {
            return res.status(400).json({ success: false, message: 'Cannot delete your own account' });
        }

        const [result] = await db.execute('DELETE FROM staff WHERE id = ?', [req.params.id]);

        if (result.affectedRows === 0) {
            return res.status(404).json({ success: false, message: 'Staff member not found' });
        }

        res.json({
            success: true,
            message: 'Staff member deleted successfully'
        });
    } catch (error) {
        console.error('Delete staff error:', error);
        res.status(500).json({ success: false, message: 'Failed to delete staff member' });
    }
});

// ============================================
// IMAGE UPLOAD ROUTES (Cloudinary)
// ============================================

// Upload single image
app.post('/api/upload/image', authenticateUser, async (req, res) => {
    try {
        const { image, folder } = req.body;

        if (!image) {
            return res.status(400).json({ success: false, message: 'Image data is required' });
        }

        const imageUrl = await uploadToCloudinary(image, folder || 'greyinsaat');

        res.json({
            success: true,
            imageUrl
        });
    } catch (error) {
        console.error('Image upload error:', error);
        res.status(500).json({ success: false, message: 'Failed to upload image' });
    }
});

// Upload multiple images
app.post('/api/upload/images', authenticateUser, async (req, res) => {
    try {
        const { images, folder } = req.body;

        if (!images || !Array.isArray(images) || images.length === 0) {
            return res.status(400).json({ success: false, message: 'Images array is required' });
        }

        if (images.length > 7) {
            return res.status(400).json({ success: false, message: 'Maximum 7 images allowed' });
        }

        const imageUrls = await uploadMultipleToCloudinary(images, folder || 'greyinsaat/projects');

        res.json({
            success: true,
            imageUrls
        });
    } catch (error) {
        console.error('Multiple images upload error:', error);
        res.status(500).json({ success: false, message: 'Failed to upload images' });
    }
});

// ============================================
// EMAIL ROUTES
// ============================================

import fs from 'fs';
import nodemailer from 'nodemailer';
import { google } from 'googleapis';

// Load Gmail credentials
let gmailCredentials = null;
try {
    const tokenPath = './myToken.json';
    if (fs.existsSync(tokenPath)) {
        gmailCredentials = JSON.parse(fs.readFileSync(tokenPath, 'utf8'));
        console.log('âœ… Gmail credentials loaded');
    } else {
        console.warn('âš ï¸ myToken.json not found. Email features will be limited.');
    }
} catch (error) {
    console.error('âŒ Failed to load Gmail credentials:', error);
}

// Create Transporter
const createTransporter = async () => {
    if (!gmailCredentials) throw new Error('Gmail credentials not available');

    const { client_id, client_secret, refresh_token, user_email } = gmailCredentials;

    // If we have a refresh token, we can create an OAuth2 client
    const OAuth2 = google.auth.OAuth2;
    const oauth2Client = new OAuth2(
        client_id,
        client_secret,
        "https://developers.google.com/oauthplayground"
    );

    oauth2Client.setCredentials({
        refresh_token: refresh_token
    });

    const accessToken = await new Promise((resolve, reject) => {
        oauth2Client.getAccessToken((err, token) => {
            if (err) {
                reject('Failed to create access token');
            }
            resolve(token);
        });
    });

    const transporter = nodemailer.createTransport({
        service: 'gmail',
        auth: {
            type: 'OAuth2',
            user: user_email, // Your gmail address
            clientId: client_id,
            clientSecret: client_secret,
            refreshToken: refresh_token,
            accessToken: accessToken
        }
    });

    return transporter;
};

// Send email
app.post('/api/email/send', authenticateUser, async (req, res) => {
    try {
        const { to, subject, body, attachments } = req.body;

        if (!to || !subject || !body) {
            return res.status(400).json({ success: false, message: 'To, subject, and body are required' });
        }

        // Parse recipients (comma separated)
        const recipients = to.split(',').map(email => email.trim()).filter(email => email);

        // Construct "Mind Blowing" HTML Template
        const htmlTemplate = `
        <!DOCTYPE html>
        <html>
        <head>
            <style>
                body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; padding: 0; background-color: #f4f4f4; }
                .container { max-width: 600px; margin: 0 auto; background-color: #ffffff; border-radius: 12px; overflow: hidden; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
                .header { background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%); color: white; padding: 30px; text-align: center; }
                .header h1 { margin: 0; font-size: 24px; font-weight: 600; letter-spacing: 1px; }
                .content { padding: 40px 30px; color: #334155; line-height: 1.6; font-size: 16px; }
                .footer { background-color: #f8fafc; padding: 20px; text-align: center; color: #94a3b8; font-size: 12px; border-top: 1px solid #e2e8f0; }
                .btn { display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; text-decoration: none; border-radius: 6px; font-weight: 600; margin-top: 20px; }
                .highlight { color: #2563eb; font-weight: 600; }
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>Grey Insaat</h1>
                </div>
                <div class="content">
                    ${body.replace(/\n/g, '<br>')}
                </div>
                <div class="footer">
                    <p>&copy; ${new Date().getFullYear()} Grey Insaat Limited. All rights reserved.</p>
                    <p>Abuja, Nigeria</p>
                </div>
            </div>
        </body>
        </html>
        `;

        // Prepare mail options
        const mailOptions = {
            from: `Grey Insaat <${gmailCredentials?.user_email || 'noreply@greyinsaat.com'}>`,
            to: recipients,
            subject: subject,
            html: htmlTemplate,
            attachments: attachments || [] // Expects array of { filename, path/content }
        };

        if (gmailCredentials) {
            const transporter = await createTransporter();
            await transporter.sendMail(mailOptions);
            console.log(`ðŸ“§ Email sent to ${recipients.length} recipients`);

            // Save to database
            await db.execute(
                'INSERT INTO sent_emails (sender_id, recipients, subject, body, attachments, status) VALUES (?, ?, ?, ?, ?, ?)',
                [req.user.id, to, subject, body, JSON.stringify(attachments || []), 'sent']
            );
        } else {
            console.log('ðŸ“§ MOCK EMAIL (No Credentials):', mailOptions);
            await new Promise(resolve => setTimeout(resolve, 1000));

            // Save mock email to database
            await db.execute(
                'INSERT INTO sent_emails (sender_id, recipients, subject, body, attachments, status) VALUES (?, ?, ?, ?, ?, ?)',
                [req.user.id, to, subject, body, JSON.stringify(attachments || []), 'sent']
            );
        }

        res.json({
            success: true,
            message: `Email sent successfully to ${recipients.length} recipient(s)`
        });
    } catch (error) {
        console.error('Send email error:', error);

        // Save failed email to database
        try {
            await db.execute(
                'INSERT INTO sent_emails (sender_id, recipients, subject, body, attachments, status, error_message) VALUES (?, ?, ?, ?, ?, ?, ?)',
                [req.user.id, req.body.to, req.body.subject, req.body.body, JSON.stringify(req.body.attachments || []), 'failed', error.message]
            );
        } catch (dbError) {
            console.error('Failed to save error email to database:', dbError);
        }

        res.status(500).json({ success: false, message: 'Failed to send email: ' + error.message });
    }
});

// Get sent emails
app.get('/api/email/sent', authenticateUser, async (req, res) => {
    try {
        const [emails] = await db.execute(`
            SELECT e.*, s.name as sender_name, s.email as sender_email
            FROM sent_emails e
            JOIN staff s ON e.sender_id = s.id
            ORDER BY e.sent_at DESC
            LIMIT 50
        `);

        res.json({
            success: true,
            emails
        });
    } catch (error) {
        console.error('Get sent emails error:', error);
        res.status(500).json({ success: false, message: 'Failed to fetch sent emails' });
    }
});

// ============================================
// HEALTH CHECK
// ============================================
app.get('/', (req, res) => {
    res.json({
        success: true,
        message: 'Grey Insaat API is running',
        version: '2.0.0'
    });
});

// Global error handler
app.use((err, req, res, next) => {
    console.error('Global error:', err);
    res.status(500).json({
        success: false,
        message: 'Internal server error'
    });
});

// Start Server
app.listen(PORT, () => {
    console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
    console.log(`ðŸ“Š Database: ${process.env.DB_NAME || 'greyinsaat_db'}`);
});
